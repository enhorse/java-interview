[Вопросы для собеседования](README.md)

# Многопоточность
+ [Расскажите о модели памяти Java?](#Расскажите-о-модели-памяти-java)
+ [Что такое «потокобезопасность»?](#Что-такое-потокобезопасность)
+ [В чём разница между _«конкуренцией»_ и _«параллелизмом»_?](#В-чём-разница-между-конкуренцией-и-параллелизмом)
+ [Что такое _«кооперативная многозадачность»_? Какой тип многозадачности использует Java? Чем обусловлен этот выбор?](#Что-такое-кооперативная-многозадачность-Какой-тип-многозадачности-использует-java-Чем-обусловлен-этот-выбор)
+ [Что такое _ordering_, _as-if-serial semantics_, _sequential consistency_, _visibility_, _atomicity_, _happens-before_, _mutual exclusion_, _safe publication_?](#Что-такое-ordering-as-if-serial-semantics-sequential-consistency-visibility-atomicity-happens-before-mutual-exclusion-safe-publication)
+ [Чем отличается процесс от потока?](#Чем-отличается-процесс-от-потока)
+ [Что такое _«зелёные потоки»_ и есть ли они в Java?](#Что-такое-зелёные-потоки-и-есть-ли-они-в-java)
+ [Каким образом можно создать поток?](#Каким-образом-можно-создать-поток)
+ [Чем различаются `Thread` и `Runnable`?](#Чем-различаются-thread-и-runnable)
+ [В чём заключается разница между методами `start()` и `run()`?](#В-чём-заключается-разница-между-методами-start-и-run)
+ [Как принудительно запустить поток?](#Как-принудительно-запустить-поток)
+ [Что такое _«монитор»_ в Java?](#Что-такое-монитор-в-java)
+ [Дайте определение понятию «синхронизация».](#Дайте-определение-понятию-синхронизация)
+ [Какие существуют способы синхронизации в Java?](#Какие-существуют-способы-синхронизации-в-java)
+ [В каких состояниях может находиться поток?](#В-каких-состояниях-может-находиться-поток)
+ [Можно ли создавать новые экземпляры класса, пока выполняется `static synchronized` метод?](#Можно-ли-создавать-новые-экземпляры-класса-пока-выполняется-static-synchronized-метод)
+ [Зачем может быть нужен `private` мьютекс?](#Зачем-может-быть-нужен-private-мьютекс)
+ [Как работают методы `wait()` и `notify()`/`notifyAll()`?](#Как-работают-методы-wait-и-notifynotifyall)
+ [В чем разница между `notify()` и `notifyAll()`?](#В-чем-разница-между-notify-и-notifyall)
+ [Почему методы `wait()` и `notify()` вызываются только в синхронизированном блоке?](#Почему-методы-wait-и-notify-вызываются-только-в-синхронизированном-блоке)
+ [Чем отличается работа метода `wait()` с параметром и без параметра?](#Чем-отличается-работа-метода-wait-с-параметром-и-без-параметра)
+ [Чем отличаются методы `Thread.sleep()` и `Thread.yield()`?](#Чем-отличаются-методы-threadsleep-и-threadyield)
+ [Как работает метод `Thread.join()`?](#Как-работает-метод-threadjoin)
+ [Что такое _deadlock_?](#Что-такое-deadlock)
+ [Что такое _livelock_?](#Что-такое-livelock)
+ [Как проверить, удерживает ли поток монитор определённого ресурса?](#Как-проверить-удерживает-ли-поток-монитор-определённого-ресурса)
+ [На каком объекте происходит синхронизация при вызове `static synchronized` метода?](#На-каком-объекте-происходит-синхронизация-при-вызове-static-synchronized-метода)
+ [Для чего используется ключевое слово `volatile`, `synchronized`, `transient`, `native`?](#Для-чего-используется-ключевое-слово-volatile-synchronized-transient-native)
+ [В чём различия между `volatile` и _Atomic_ переменными?](#В-чём-различия-между-volatile-и-atomic-переменными)
+ [ В чём заключаются различия между `java.util.concurrent.Atomic*.compareAndSwap()` и `java.util.concurrent.Atomic*.weakCompareAndSwap()`.](#-В-чём-заключаются-различия-между-javautilconcurrentatomiccompareandswap-и-javautilconcurrentatomicweakcompareandswap)
+ [Что значит _«приоритет потока»_?](#Что-значит-приоритет-потока)
+ [Что такое _«потоки-демоны»_?](#Что-такое-потоки-демоны)
+ [Можно ли сделать основной поток программы демоном?](#Можно-ли-сделать-основной-поток-программы-демоном)
+ [Что значит _«усыпить»_ поток?](#Что-значит-усыпить-поток)
+ [Чем отличаются два интерфейса `Runnable` и `Callable`?](#Чем-отличаются-два-интерфейса-runnable-и-callable)
+ [Что такое `FutureTask`?](#Что-такое-futuretask)
+ [В чем заключаются различия между `CyclicBarrier` и `CountDownLatch`?](#В-чем-заключаются-различия-между-cyclicbarrier-и-countdownlatch)
+ [Что такое _race condition_?](#Что-такое-race-condition)
+ [Существует ли способ решения проблемы _race condition_?](#Существует-ли-способ-решения-проблемы-race-condition)
+ [Как остановить поток?](#Как-остановить-поток)
+ [Почему не рекомендуется использовать метод `Thread.stop()`?](#Почему-не-рекомендуется-использовать-метод-threadstop)
+ [Что происходит, когда в потоке выбрасывается исключение?](#Что-происходит-когда-в-потоке-выбрасывается-исключение)
+ [В чем разница между `interrupted()` и `isInterrupted()`?](#В-чем-разница-между-interrupted-и-isinterrupted)
+ [Что такое _«пул потоков»_?](#Что-такое-пул-потоков)
+ [Какого размера должен быть пул потоков?](#Какого-размера-должен-быть-пул-потоков)
+ [Что будет, если очередь пула потоков уже заполнена, но подаётся новая задача?](#Что-будет-если-очередь-пула-потоков-уже-заполнена-но-подаётся-новая-задача)
+ [В чём заключается различие между методами `submit()` и `execute()` у пула потоков?](#В-чём-заключается-различие-между-методами-submit-и-execute-у-пула-потоков)
+ [В чем заключаются различия между cтеком (stack) и кучей (heap) с точки зрения многопоточности?](#В-чем-заключаются-различия-между-cтеком-stack-и-кучей-heap-с-точки-зрения-многопоточности)
+ [Как поделиться данными между двумя потоками?](#Как-поделиться-данными-между-двумя-потоками)
+ [Какой параметр запуска JVM используется для контроля размера стека потока?](#Какой-параметр-запуска-jvm-используется-для-контроля-размера-стека-потока)
+ [Как получить дамп потока?](#Как-получить-дамп-потока)
+ [Что такое _ThreadLocal-переменная_?](#Что-такое-threadlocal-переменная)
+ [Назовите различия между `synchronized` и `ReentrantLock`?](#Назовите-различия-между-synchronized-и-reentrantlock)
+ [Что такое `ReadWriteLock`?](#Что-такое-readwritelock)
+ [Что такое _«блокирующий метод»_?](#Что-такое-блокирующий-метод)
+ [Что такое _«фреймворк Fork/Join»_?](#Что-такое-фреймворк-forkjoin)
+ [Что такое `Semaphore`?](#Что-такое-semaphore)
+ [Что такое _double checked locking Singleton_?](#Что-такое-double-checked-locking-singleton)
+ [Как создать потокобезопасный Singleton?](#Как-создать-потокобезопасный-singleton)
+ [Чем полезны неизменяемые объекты?](#Чем-полезны-неизменяемые-объекты)
+ [Что такое _busy spin_?](#Что-такое-busy-spin)
+ [Перечислите принципы, которым вы следуете в многопоточном программировании?](#Перечислите-принципы-которым-вы-следуете-в-многопоточном-программировании)
+ [Какое из следующих утверждений о потоках неверно?](#Какое-из-следующих-утверждений-о-потоках-неверно)
+ [Даны 3 потока Т1, Т2 и Т3? Как реализовать выполнение в последовательности Т1, Т2, Т3?](#Даны-3-потока-Т1-Т2-и-Т3-Как-реализовать-выполнение-в-последовательности-Т1-Т2-Т3)
+ [Напишите минимальный неблокирующий стек (всего два метода — `push()` и `pop()`).](#Напишите-минимальный-неблокирующий-стек-всего-два-метода--push-и-pop)
+ [Напишите минимальный неблокирующий стек (всего два метода — `push()` и `pop()`) с использованием `Semaphore`.](#Напишите-минимальный-неблокирующий-стек-всего-два-метода--push-и-pop-с-использованием-semaphore)
+ [Напишите минимальный неблокирующий ArrayList (всего четыре метода — `add()`, `get()`, `remove()`, `size()`).](#Напишите-минимальный-неблокирующий-arraylist-всего-четыре-метода--add-get-remove-size)
+ [Напишите потокобезопасную реализацию класса с неблокирующим методом `BigInteger next()`, который возвращает элементы последовательности: `[1, 2, 4, 8, 16, ...]`.](#Напишите-потокобезопасную-реализацию-класса-с-неблокирующим-методом-biginteger-next-который-возвращает-элементы-последовательности-1-2-4-8-16-)
+ [Напишите простейший многопоточный ограниченный буфер с использованием `synchronized`.](#Напишите-простейший-многопоточный-ограниченный-буфер-с-использованием-synchronized)
+ [Напишите простейший многопоточный ограниченный буфер с использованием `ReentrantLock`.](#Напишите-простейший-многопоточный-ограниченный-буфер-с-использованием-reentrantlock)

## Расскажите о модели памяти Java?
__Модель памяти Java (Java Memory Model, JMM)__ описывает поведение потоков в среде исполнения Java. Это часть семантики языка Java, набор правил, описывающий выполнение многопоточных программ и правил, по которым потоки могут взаимодействовать друг с другом посредством основной памяти.

Формально модель памяти определяет набор действий межпоточного взаимодействия (эти действия включают в себя, в частности, чтение и запись переменной, захват и освобождений монитора, чтение и запись volatile переменной, запуск нового потока), а также модель памяти определяет отношение между этими действиями -_happens-before_ - абстракции обозначающей, что если операция _X_ связана отношением happens-before с операцией _Y_, то весь код следуемый за операцией _Y_, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции _X_.

Существует несколько основных правил для отношения happens-before:

+ В рамках одного потока любая операция happens-before любой операцией, следующей за ней в исходном коде;
+ Освобождение монитора (unlock) happens-before захват того же монитора (lock);
+ Выход из `synchronized` блока/метода happens-before вход в `synchronized` блок/метод на том же мониторе;
+ Запись `volatile` поля happens-before чтение того же самого `volatile` поля;
+ Завершение метода `run()` экземпляра класса `Thread` happens-before выход из метода `join()` или возвращение `false` методом `isAlive()` экземпляром того же потока;
+ Вызов метода `start()` экземпляра класса `Thread` happens-before начало метода `run()` экземпляра того же потока;
+ Завершение конструктора happens-before начало метода `finalize()` этого класса;
+ Вызов метода `interrupt()` на потоке happens-before обнаружению потоком факта, что данный метод был вызван либо путем выбрасывания исключения `InterruptedException`, либо с помощью методов `isInterrupted()` или `interrupted()`.
+ Связь happens-before транзитивна, т.е. если _X_ happens-before _Y_, а _Y_ happens-before _Z_, то _X_ happens-before _Z_.
+ Освобождение/захват монитора и запись/чтение в `volatile` переменную связаны отношением happens-before, только если операции проводятся над одним и тем же экземпляром объекта.
+ В отношении happens-before участвуют только два потока, о поведении остальных потоков ничего сказать нельзя, пока в каждом из них не наступит отношение happens-before с другим потоком.

Можно выделить несколько основных областей, имеющих отношение к модели памяти:

_Видимость (visibility)_. Один поток может в какой-то момент временно сохранить значение некоторых полей не в основную память, а в регистры или локальный кэш процессора, таким образом второй поток, выполняемый на другом процессоре, читая из основной памяти, может не увидеть последних изменений поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами и локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных другим потоком в основную память.

К вопросу видимости имеют отношение следующие ключевые слов языка Java: `synchronized`, `volatile`, `final`. 

С точки зрения Java все переменные (за исключением локальных переменных, объявленных внутри метода) хранятся в главной памяти, которая доступна всем потокам, кроме этого, каждый поток имеет локальную—рабочую—память, где он хранит копии переменных, с которыми он работает, и при выполнении программы поток работает только с этими копиями. Надо отметить, что это описание не требование к реализации, а всего лишь модель, которая объясняет поведение программы, так, в качестве локальной памяти не обязательно выступает кэш память, это могут быть регистры процессора или потоки могут вообще не иметь локальной памяти.

При входе в `synchronized` метод или блок поток обновляет содержимое локальной памяти, а при выходе из `synchronized` метода или блока поток записывает изменения, сделанные в локальной памяти, в главную. Такое поведение `synchronized` методов и блоков следует из правил для отношения «происходит раньше»: так как все операции с памятью происходят раньше освобождения монитора и освобождение монитора происходит раньше захвата монитора, то все операции с памятью, которые были сделаны потоком до выхода из `synchronized` блока должны быть видны любому потоку, который входит в `synchronized` блок для того же самого монитора. Очень важно, что это правило работает только в том случае, если потоки синхронизируются, используя один и тот же монитор! 

Что касается `volatile` переменных, то запись таких переменных производится в основную память, минуя локальную. и чтение `volatile` переменной производится также из основной памяти, то есть значение переменной не может сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт последнее записанное в неё значение.

Также модель памяти определяет дополнительную семантику ключевого слова `final`, имеющую отношение к видимости: после того как объект был корректно создан, любой поток может видеть значения его `final` полей без дополнительной синхронизации. «Корректно создан» означает, что ссылка на создающийся объект не должна использоваться до тех пор, пока не завершился конструктор объекта. Наличие такой семантики для ключевого слова `final` позволяет создание неизменяемых (immutable) объектов, содержащих только `final` поля, такие объекты могут свободно передаваться между потоками без обеспечения синхронизации при передаче.

Есть одна проблема, связанная с `final` полями: реализация разрешает менять значения таких полей после создания объекта (это может быть сделано, например, с использованием механизма reflection). Если значение `final` поля—константа, чьё значение известно на момент компиляции, изменения такого поля могут не иметь эффекта, так-как обращения к этой переменной могли быть заменены компилятором на константу. Также спецификация разрешает другие оптимизации, связанные с `final` полями, например, операции чтения `final` переменной могут быть переупорядочены с операциями, которые потенциально могут изменить такую переменную. Так что рекомендуется изменять `final` поля объекта только внутри конструктора, в противном случае поведение не специфицировано.

_Reordering (переупорядочивание)_. Для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции/операции. Вернее, с точки зрения потока, наблюдающего за выполнением операций в другом потоке, операции могут быть выполнены не в том порядке, в котором они идут в исходном коде. Тот же эффект может наблюдаться, когда один поток кладет результаты первой операции в регистр или локальный кэш, а результат второй операции попадает непосредственно в основную память. Тогда второй поток, обращаясь к основной памяти может сначала увидеть результат второй операции, и только потом первой, когда все регистры или кэши синхронизируются с основной памятью. Еще одна причина reordering, может заключаться в том, что процессор может решить поменять порядок выполнения операций, если, например, сочтет что такая последовательность выполнится быстрее.

Вопрос reordering также регулируется набором правил для отношения «происходит раньше» и у этих правил есть следствие, касающееся порядка операций, используемое на практике: операции чтения и записи `volatile` переменных не могут быть переупорядочены с операциями чтения и записи других `volatile` и не-`volatile` переменных. Это следствие делает возможным использование `volatile` переменной как флага, сигнализирующем об окончании какого-либо действия. В остальном правила, касающиеся порядка выполнения операций, гарантируют упорядоченность операций для конкретного набора случаев (таких как, например, захват и освобождение монитора), во всех остальных случаях оставляя компилятору и процессору полную свободу для оптимизаций.

[к оглавлению](#Многопоточность)

## Что такое «потокобезопасность»?
Потокобезопасность – свойство объекта или кода, которое гарантирует, что при исполнении или использовании несколькими потоками, код будет вести себя, как предполагается. Например потокобезопасный счётчик не пропустит ни один счёт, даже если один и тот же экземпляр этого счётчика будет использоваться несколькими потоками.

[к оглавлению](#Многопоточность)

## В чём разница между _«конкуренцией»_ и _«параллелизмом»_?
Конкуренция — это способ одновременного решения множества задач.

Признаки:

+ Наличие нескольких потоков управления (например, _Thread_ в Java, _корутина_ в Kotlin), если поток управления один, то конкурентного выполнения быть не может
+ Недетерминированный результат выполнения. Результат зависит от случайных событий, реализации и того, как была проведена синхронизация. Даже если каждый поток полностью детерминированный, итоговый результат будет недетерминированным

Параллелизм — это способ выполнения разных частей одной задачи.

Признаки:

+ Необязательно имеет несколько потоков управления
+ Может приводить к детерминированному результату, так, например, результат умножения каждого элемента массива на число, не изменится, если умножать его по частям параллельно.

[к оглавлению](#Многопоточность)

## Что такое _«кооперативная многозадачность»_? Какой тип многозадачности использует Java? Чем обусловлен этот выбор?

__Кооперативная многозадачность__ - это способ деления процессорного времени между потоками, при котором каждый поток обязан отдавать управление следующему добровольно.

Преимущества такого подхода - простота реализации, меньшие накладные расходы на переключение контекста.

Недостатки - если один поток завис или ведет себя некорректно, то зависает целиком вся система и другие потоки никогда не получат управление.

Java использует __вытесняющую многозадачность__, при которой решение о переключении между потоками процесса принимает операционная система.

В отличие от кооперативной многозадачности управление операционной системе передаётся вне зависимости от состояния работающих приложений, благодаря чему, отдельные зависшие потоки процесса, как правило, не «подвешивают» всю систему целиком. За счёт регулярного переключения между задачами также улучшается отзывчивость приложения и повышается оперативность освобождения ресурсов, которые больше не используются.

В реализации вытесняющая многозадачность отличается от кооперативной, в частности, тем, что требует обработки системного прерывания от аппаратного таймера.

[к оглавлению](#Многопоточность)

## Что такое _ordering_, _as-if-serial semantics_, _sequential consistency_, _visibility_, _atomicity_, _happens-before_, _mutual exclusion_, _safe publication_?
__ordering__ механизм, который определяет, когда один поток может увидеть _out-of-order_ (неверный) порядок исполнения инструкций другого потока. CPU для повышения производительности может переупорядочивать процессорные инструкции и выполнять их в произвольном порядке  до тех пор пока для потока внутри не будет видно никаких отличий. Гарантия, предоставляемая этим механизмом, называется __as-if-serial semantics__.

__sequential consistency__ - то же что и _as-if-serial semantics_, гарантия того, что в рамках одного потока побочные эффекты от всех операций будут такие, как будто все операции выполняются последовательно.

__visibility__  определяет, когда действия в одном потоке становятся видны из другого потока.

__happens-before__ - логическое ограничение на порядок выполнения инструкций программы. Если указывается, что запись в переменную и последующее ее чтение связаны через эту зависимость, то как бы при выполнении не переупорядочивались инструкции, в момент чтения все связанные с процессом записи результаты уже зафиксированы и видны.

__atomicity__ — атомарность операций. Атомарная операция выглядит единой и неделимой командой процессора, которая может быть или уже выполненной или ещё невыполненной.

__mutual exclusion__ (взаимоисключающая блокировка, семафор с одним состоянием) - механизм, гарантирующий потоку исключительный доступ к ресурсу. Используется для предотвращения одновременного доступа к общему ресурсу. В каждый момент времени таким ресурсом может владеть только один поток. Простейший пример: `synchronized(obj) { … }`.

__safe publication__? - показ объектов другим потокам из текущего, не нарушая ограничений _visibility_. Способы такой публикации в Java:

+ `static{}` инициализатор;
+ `volatile` переменные;
+ `atomic` переменные;
+ сохранение в разделяемой переменной, корректно защищенной с использованием `synchronized()`, синхронизаторов или других конструкций, создающих _read/write memory barrier_;
+ `final` переменные в разделяемом объекте, который был корректно проинициализирован.

[к оглавлению](#Многопоточность)

## Чем отличается процесс от потока?
__Процесс__ — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.

Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.

__Поток__(thread) — определенный способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах.
Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах.
Так как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов.

[к оглавлению](#Многопоточность)

## Что такое _«зелёные потоки»_ и есть ли они в Java?
__Зелёные (легковесные) потоки__(green threads) - потоки эмулируемые виртуальной машиной или средой исполнения. Создание зелёного потока не подразумевает под собой создание реального потока ОС.

Виртуальная машина Java берёт на себя заботу о переключении между разными green threads, а сама машина работает как один поток ОС. Это даёт несколько преимуществ. Потоки ОС относительно дороги в большинстве POSIX-систем. Кроме того, переключение между native threads гораздо медленнее, чем между green threads.

Это всё означает, что в некоторых ситуациях green threads гораздо выгоднее, чем native threads. Система может поддерживать гораздо большее количество green threads, чем потоков OС. Например, гораздо практичнее запускать новый green thread для нового HTTP-соединения к веб-серверу, вместо создания нового native thread.

Однако есть и недостатки. Самый большой заключается в том, что вы не можете исполнять два потока одновременно. Поскольку существует только один native thread, только он и вызывается планировщиком ОС. Даже если у вас несколько процессоров и несколько green threads, только один процессор может вызывать green thread. И всё потому, что с точки зрения планировщика заданий ОС всё это выглядит одним потоком.

Начиная с версии 1.2 Java поддерживает native threads, и с тех пор они используются по умолчанию.

[к оглавлению](#Многопоточность)

## Каким образом можно создать поток?
+ Создать потомка класса `Thread` и переопределить его метод `run()`;
+ Создать объект класса `Thread`, передав ему в конструкторе экземпляр класса, реализующего интерфейс `Runnable`. Эти интерфейс содержит метод `run()`, который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод `run()`.
+ Вызвать метод `submit()` у экземпляра класса реализующего интерфейс `ExecutorService`, передав ему в качестве параметра экземпляр класса реализующего интерфейс `Runnable` или `Callable` (содержит метод `call()`, в котором описывается логика выполнения).

[к оглавлению](#Многопоточность)

## Чем различаются `Thread` и `Runnable`?
`Thread` - это класс, некоторая надстройка над физическим потоком.

`Runnable` - это интерфейс, представляющий абстракцию над выполняемой задачей.

Помимо того, что `Runnable` помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком.

[к оглавлению](#Многопоточность)

## В чём заключается разница между методами `start()` и `run()`?
Несмотря на то, что `start()` вызывает метод `run()` внутри себя, это не то же самое, что просто вызов `run()`. Если `run()` вызывается как обычный метод, то он вызывается в том же потоке и никакой новый поток не запускается, как это происходит, в случае, когда вы вызываете метод `start()`.

[к оглавлению](#Многопоточность)

## Как принудительно запустить поток?
Никак. В Java не существует абсолютно никакого способа принудительного запуска потока. Это контролируется JVM и Java не предоставляет никакого API для управления этим процессом.

[к оглавлению](#Многопоточность)

## Что такое _«монитор»_ в Java?
__Монитор__, мьютекс (mutex) – это средство обеспечения контроля за доступом к ресурсу. У монитора может быть максимум один владелец в каждый текущий момент времени. Следовательно, если кто-то использует ресурс и захватил монитор для обеспечения единоличного доступа, то другой, желающий использовать тот же ресурс, должен подождать освобождения монитора, захватить его и только потом начать использовать ресурс.

Удобно представлять монитор как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.

В Java у каждого экземпляра объекта есть монитор, который контролируется непосредственно виртуальной машиной. Используется он так: любой нестатический `synchronized`-метод при своем вызове прежде всего пытается захватить монитор того объекта, у которого он вызван (на который он может сослаться как на `this`). Если это удалось – метод исполняется. Если нет – поток останавливается и ждет, пока монитор будет отпущен.

[к оглавлению](#Многопоточность)

## Дайте определение понятию «синхронизация».
Синхронизация - это процесс, который позволяет выполнять потоки параллельно.

В Java все объекты имеют одну блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта. Если поток получил блокировку, ни один другой поток не может войти в синхронизированный код, пока блокировка не будет снята. Когда поток, владеющий блокировкой, выходит из синхронизированного кода, блокировка снимается. Теперь другой поток может получить блокировку объекта и выполнить синхронизированный код. Если поток пытается получить блокировку объекта, когда другой поток владеет блокировкой, поток переходит в состояние Блокировки до тех пор, пока блокировка не снимется.

[к оглавлению](#Многопоточность)

## Какие существуют способы синхронизации в Java?
+ __Системная синхронизация с использованием `wait()`/`notify()`__. Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод `wait()`, предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод `notify()` (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через `synchronized`-блок, потому как методы `wait()`/`notify()` не синхронизированы!

+ __Системная синхронизация с использованием `join()`__. Метод `join()`, вызванный у экземпляра класса `Thread`, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.

+ __Использование классов из пакета `java.util.concurrent`__, который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - `Lock`, `Semaphore` и пр.. Концепция данного подхода заключается в использовании атомарных операций и переменных.

[к оглавлению](#Многопоточность)

## В каких состояниях может находиться поток?
Потоки могут находиться в одном из следующих состояний:

+ __Новый (New)__. После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод `start()`. В этом состоянии поток не считается живым.
+ __Работоспособный (Runnable)__. Поток переходит в состояние Работоспособный, когда вызывается метод `start()`. Поток может перейти в это состояние также из состояния Работающий или из состояния Блокирован. Когда поток находится в этом состоянии, он считается живым.
+ __Работающий (Running)__. Поток переходит из состояния Работоспособный в состояние Работающий, когда Планировщик потоков выбирает его как работающий в данный момент.
+ __Живой, но не работоспособный (Alive, but not runnable)__. Поток может быть живым, но не работоспособным по нескольким причинам:
    + __Ожидание (Waiting)__. Поток переходит в состояние Ожидания, вызывая метод `wait()`. Вызов `notify()` или `notifyAll()` может перевести поток из состояния Ожидания в состояние Работоспособный. 
    + __Сон (Sleeping)__. Метод `sleep()` переводит поток в состояние Сна на заданный промежуток времени в миллисекундах.
    + __Блокировка (Blocked)__. Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за блокировки другого объекта. В этом случае поток переходит в состояние Работоспособный, когда ресурс становится доступен.
    + __Мёртвый (Dead)__. Поток считается мёртвым, когда его метод `run()` полностью выполнен. Мёртвый поток не может перейти ни в какое другое состояние, даже если для него вызван метод `start()`.

[к оглавлению](#Многопоточность)

## Можно ли создавать новые экземпляры класса, пока выполняется `static synchronized` метод?
Да, можно создавать новые экземпляры класса, так как статические поля не принадлежат к экземплярам класса.

[к оглавлению](#Многопоточность)

## Зачем может быть нужен `private` мьютекс?
Объект для синхронизации делается `private`, чтобы сторонний код не мог на него синхронизироваться и случайно получить взаимную блокировку.

[к оглавлению](#Многопоточность)

## Как работают методы `wait()` и `notify()`/`notifyAll()`?
Эти методы определены у класса `Object` и предназначены для взаимодействия потоков между собой при межпоточной синхронизации.

+ `wait()`: освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод `notify()`/`notifyAll()`;
+ `notify()`: продолжает работу потока, у которого ранее был вызван метод `wait()`;
+ `notifyAll()`: возобновляет работу всех потоков, у которых ранее был вызван метод `wait()`.

Когда вызван метод `wait()`, поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод `notify()` подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод `notifyAll()` заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). Если ни один поток не находится в ожидании на методе `wait()`, то при вызове `notify()` или `notifyAll()` ничего не происходит.

Поток может вызвать методы `wait()` или `notify()` для определённого объекта, только если он в данный момент имеет блокировку на этот объект. `wait()`, `notify()` и `notifyAll()` должны вызываться только из синхронизированного кода.

[к оглавлению](#Многопоточность)

## В чем разница между `notify()` и `notifyAll()`? 
Дело в том, что «висеть» на методе `wait()` одного монитора могут сразу несколько потоков. При вызове `notify()` только один из них выходит из `wait()` и пытается захватить монитор, а затем продолжает работу со следующего после `wait()` оператора. Какой из них выйдет - заранее неизвестно. А при вызове `notifyAll()`, все висящие на `wait()` потоки выходят из `wait()`, и все они пытаются захватить монитор. Понятно, что в любой момент времени монитор может быть захвачен только одним потоком, а остальные ждут своей очереди. Порядок очереди определяется планировщиком потоков Java.

[к оглавлению](#Многопоточность)

## Почему методы `wait()` и `notify()` вызываются только в синхронизированном блоке?
Монитор надо захватывать в явном виде (через `synchronized`-блок), потому что методы `wait()` и `notify()` не синхронизированы.

[к оглавлению](#Многопоточность)

## Чем отличается работа метода `wait()` с параметром и без параметра?
`wait()`

+ __без параметров__ освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод `notify()`/`notifyAll()`, 
+ __с параметрами__ заставит поток ожидать заданное количество времени или вызова `notify()`/`notifyAll()`.

[к оглавлению](#Многопоточность)

## Чем отличаются методы `Thread.sleep()` и `Thread.yield()`?
Метод `yield()` служит причиной того, что поток переходит из состояния работающий (running) в состояние работоспособный (runnable), давая возможность другим потокам активизироваться. Но следующий выбранный для запуска поток может и не быть другим.

Метод `sleep()` вызывает засыпание текущего потока на заданное время, состояние изменяется с работающий (running) на ожидающий (waiting).

[к оглавлению](#Многопоточность)

## Как работает метод `Thread.join()`?
Когда поток вызывает `join()` для другого потока, текущий работающий поток будет ждать, пока другой поток, к которому он присоединяется, не будет завершён:

```java
void join()        
void join(long millis) 
void join(long millis, int nanos) 
```

[к оглавлению](#Многопоточность)

## Что такое _deadlock_?
__Взаимная блокировка (deadlock)__ - явление, при котором все потоки находятся в режиме ожидания. Происходит, когда достигаются состояния:

1. взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и, следовательно, только один поток может использовать ресурс в любой данный момент времени.
2. удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсов, которые удерживаются другими потоками.
3. отсутствия предочистки: операционная система не переназначивает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.
4. цикличного ожидания: поток ждёт освобождения ресурса, другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.
 
Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.

[к оглавлению](#Многопоточность)

## Что такое _livelock_?
_livelock_ – тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в зацикленность при попытке получения каких-либо ресурсов. При этом их состояния постоянно изменяются в зависимости друг от друга. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock.

> Реальный пример livelock, – когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.

[к оглавлению](#Многопоточность)

## Как проверить, удерживает ли поток монитор определённого ресурса?
Метод `Thread.holdsLock(lock)` возвращает `true`, когда текущий поток удерживает монитор у определённого объекта.

[к оглавлению](#Многопоточность)

## На каком объекте происходит синхронизация при вызове `static synchronized` метода?
У синхронизированного статического метода нет доступа к `this`, но есть доступ к объекту класса `Class`, он присутствует в единственном экземпляре и именно он выступает в качестве монитора для синхронизации статических методов. Таким образом, следующая конструкция:

```java
public class SomeClass {

    public static synchronized void someMethod() {
        //code
    }
}
```

эквивалентна такой:

```java
public class SomeClass {

    public static void someMethod(){
        synchronized(SomeClass.class){
            //code
        }
    }
}
```

[к оглавлению](#Многопоточность)

## Для чего используется ключевое слово `volatile`, `synchronized`, `transient`, `native`?
__`volatile`__ - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности. Если же переменная является ссылкой на объект – синхронизировано будет исключительно значение этой ссылки. Все же данные, содержащиеся в объекте, синхронизированы не будут!

__`synchronized`__ - это зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода.

Ключевые слова `transient` и `native` к многопоточности никакого отношения не имеют, первое используется для указания полей класса, которые не нужно сериализовать, а второе - сигнализирует о том, что метод реализован в платформо-зависимом коде.

[к оглавлению](#Многопоточность)

## В чём различия между `volatile` и _Atomic_ переменными?
`volatile` принуждает использовать единственный экземпляр переменной, но не гарантирует атомарность. Например, операция `count++` не станет атомарной просто потому, что `count` объявлена `volatile`. C другой стороны `class AtomicInteger` предоставляет атомарный метод для выполнения таких комплексных операций атомарно, например `getAndIncrement()` – атомарная замена оператора инкремента, его можно использовать, чтобы атомарно увеличить текущее значение на один. Похожим образом сконструированы атомарные версии и для других типов данных.

[к оглавлению](#Многопоточность)

##  В чём заключаются различия между `java.util.concurrent.Atomic*.compareAndSwap()` и `java.util.concurrent.Atomic*.weakCompareAndSwap()`.
+ `weakCompareAndSwap()` не создает _memory barrier_ и не дает гарантии _happens-before_;
+ `weakCompareAndSwap()` сильно зависит от кэша/CPU, и может возвращать `false` без видимых причин;
+ `weakCompareAndSwap()`, более легкая, но поддерживаемая далеко не всеми архитектурами и не всегда эффективная операция.

[к оглавлению](#Многопоточность)

## Что значит _«приоритет потока»_?
Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета.

Чтобы установить приоритет потока, используется метод класса `Thread`: `final void setPriority(int level)`. Значение `level` изменяется в пределах от `Thread.MIN_PRIORITY = 1` до `Thread.MAX_PRIORITY = 10`. Приоритет по умолчанию - `Thread.NORM_PRlORITY = 5`.

Получить текущее значение приоритета потока можно вызвав метод: `final int getPriority()` у экземпляра класса `Thread`.

[к оглавлению](#Многопоточность)

## Что такое _«потоки-демоны»_?
Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода `setDaemon(boolean value)`, вызванного у потока до его запуска. Метод `boolean isDaemon()` позволяет определить, является ли указанный поток демоном или нет. Базовое свойство потоков-демонов заключается в возможности основного потока приложения завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода `main()`, не обращая внимания на то, что поток-демон еще работает.

[к оглавлению](#Многопоточность)

## Можно ли сделать основной поток программы демоном?
Нет. Потоки-демоны позволяют описывать фоновые процессы, которые нужны только для обслуживания основных потоков выполнения и не могут существовать без них.

[к оглавлению](#Многопоточность)

## Что значит _«усыпить»_ поток?
Это значит приостановить его на определенный промежуток времени, вызвав в ходе его выполнения статический метод `Thread.sleep()` передав в качестве параметра необходимое количество времени в  миллисекундах. До истечения этого времени поток может быть выведен из состояния ожидания вызовом `interrupt()` с выбрасыванием `InterruptedException`.

[к оглавлению](#Многопоточность)

## Чем отличаются два интерфейса `Runnable` и `Callable`?
+ Интерфейс `Runnable` появился в Java 1.0, а интерфейс `Callable` был введен в Java 5.0 в составе библиотеки `java.util.concurrent`;
+ Классы, реализующие интерфейс `Runnable` для выполнения задачи должны реализовывать метод `run()`. Классы, реализующие интерфейс `Callable` - метод `call()`;
+ Метод `Runnable.run()` не возвращает никакого значения, `Callable.call()` возвращает объект `Future`, который может содержать результат вычислений;
+ Метод `run()` не может выбрасывать проверяемые исключения, в то время как метод `call()` может.

[к оглавлению](#Многопоточность)

## Что такое `FutureTask`?
`FutureTask` представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. Этот класс предоставляет базовую реализацию `Future`, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. Объекты `FutureTask` могут быть использованы для обёртки объектов `Callable` и `Runnable`. Так как `FutureTask` реализует `Runnable`, его можно передать в `Executor` на выполнение.

[к оглавлению](#Многопоточность)

## В чем заключаются различия между `CyclicBarrier` и `CountDownLatch`?
`CountDownLatch` (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор, пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены», чтобы продолжить свою деятельность. В конструктор `CountDownLatch(int count)` обязательно передается количество операций, которое должно быть выполнено, чтобы замок «отпустил» заблокированные потоки.

> Примером `CountDownLatch` из жизни может служить сбор экскурсионной группы: пока не наберется определенное количество человек, экскурсия не начнется.

`CyclicBarrier` реализует шаблон синхронизации «Барьер». Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». В конструкторы барьера `CyclicBarrier(int parties)` и `CyclicBarrier(int parties, Runnable barrierAction)` обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены». 

> `CyclicBarrier` является альтернативой метода `join()`, который «собирает» потоки только после того, как они выполнились.

`CyclicBarrier` похож на `CountDownLatch`, но главное различие между ними в том, что использовать «замок» можно лишь единожды - после того, как его счётчик достигнет нуля, а «барьер» можно использовать неоднократно, даже после того, как он «сломается».

[к оглавлению](#Многопоточность)

## Что такое _race condition_?
__Состояние гонки__ (race condition) - ошибка проектирования многопоточной системы или приложения, при которой эта работа напрямую зависит от того, в каком порядке выполняются потоки. Состояние гонки возникает, когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток: поведение кода изменяется, из-за чего возникают недетерменированные ошибки.

[к оглавлению](#Многопоточность)

## Существует ли способ решения проблемы _race condition_?
Распространённые способы решения:

+ __Использование локальной копии__ — копирование разделяемой переменной в локальную переменную потока. Этот способ работает только тогда, когда переменная одна и копирование производится атомарно (за одну машинную команду), использование `volatile`.
+ __Синхронизация__ - операции над разделяемым ресурсом происходят в синхронизированном блоке (при использовании ключевого слова `synchronized`).
+ __Комбинирование методов__ - вышеперечисленные способы можно комбинировать, копируя «опасные» переменные в синхронизированном блоке. С одной стороны, это снимает ограничение на атомарность, с другой — позволяет избавиться от слишком больших синхронизированных блоков.

Очевидных способов выявления и исправления состояний гонки не существует. Лучший способ избавиться от гонок — правильное проектирование многозадачной системы.

[к оглавлению](#Многопоточность)

## Как остановить поток?
На данный момент в Java принят уведомительный порядок остановки потока (хотя JDK 1.0 и имеет несколько управляющих выполнением потока методов, например `stop()`, `suspend()` и `resume()` - в следующих версиях JDK все они были помечены как `deprecated` из-за потенциальных угроз взаимной блокировки).

Для корректной остановки потока можно использовать метод класса `Thread` - `interrupt()`. Этот метод выставляет некоторый внутренний флаг-статус прерывания. В дальнейшем состояние этого флага можно проверить с помощью метода `isInterrupted()` или `Thread.interrupted()` (для текущего потока). Метод `interrupt()` также способен вывести поток из состояния ожидания или спячки. Т.е. если у потока были вызваны методы `sleep()` или `wait()` – текущее состояние прервется и будет выброшено исключение `InterruptedException`. Флаг в этом случае не выставляется.

Схема действия при этом получается следующей:

+ Реализовать поток. 
+ В потоке периодически проводить проверку статуса прерывания через вызов `isInterrupted()`.
+ Если состояние флага изменилось или было выброшено исключение во время ожидания/спячки, следовательно поток пытаются остановить извне. 
+ Принять решение – продолжить работу (если по каким-то причинам остановиться невозможно) или освободить заблокированные потоком ресурсы и закончить выполнение.

Возможная проблема, которая присутствует в этом подходе – блокировки на потоковом вводе-выводе. Если поток заблокирован на чтении данных - вызов `interrupt()` из этого состояния его не выведет. Решения тут различаются в зависимости от типа источника данных. Если чтение идет из файла – долговременная блокировка крайне маловероятна и тогда можно просто дождаться выхода из метода `read()`. Если же чтение каким-то образом связано с сетью – стоит использовать неблокирующий ввод-вывод из Java NIO.

Второй вариант реализации метода остановки (а также и приостановки) – сделать собственный аналог `interrupt()`. Т.е. объявить в классе потока флаги – на остановку и/или приостановку и выставлять их путем вызова заранее определённых методов извне. Методика действия при этом остаётся прежней – проверять установку флагов и принимать решения при их изменении. Недостатки такого подхода. Во-первых, потоки в состоянии ожидания таким способом не «оживить». Во-вторых, выставление флага одним потоком совсем не означает, что второй поток тут же его увидит. Для увеличения производительности виртуальная машина использует кеш данных потока, в результате чего обновление переменной у второго потока может произойти через неопределенный промежуток времени (хотя допустимым решением будет объявить переменную-флаг как `volatile`).

[к оглавлению](#Многопоточность)

## Почему не рекомендуется использовать метод `Thread.stop()`?
При принудительной остановке (приостановке) потока, `stop()` прерывает поток в недетерменированном месте выполнения, в результате становится совершенно непонятно, что делать с принадлежащими ему ресурсами. Поток может открыть сетевое соединение - что в таком случае делать с данными, которые еще не вычитаны? Где гарантия, что после дальнейшего запуска потока (в случае приостановки) он сможет их дочитать? Если поток блокировал разделяемый ресурс, то как снять эту блокировку и не переведёт ли принудительное снятие к нарушению консистентности системы? То же самое можно расширить и на случай соединения с базой данных: если поток остановят посередине транзакции, то кто ее будет закрывать? Кто и как будет разблокировать ресурсы?

[к оглавлению](#Многопоточность)

## Что происходит, когда в потоке выбрасывается исключение?
+ Если исключение не поймано – поток «умирает» (переходит в состяние мёртв (dead)). 
+ Если установлен обработчик непойманных исключений, то он возьмёт управление на себя. `Thread.UncaughtExceptionHandler` – интерфейс, определённый как вложенный интерфейс для других обработчиков, вызываемых, когда поток внезапно останавливается из-за непойманного исключения. В случае, если поток собирается остановиться из-за непойманного исключения, JVM проверяет его на наличие `UncaughtExceptionHandler`, используя `Thread.getUncaughtExceptionHandler()`, и если такой обработчик найдет, то вызовет у него метод `uncaughtException()`, передав этот поток и исключение в виде аргументов.

[к оглавлению](#Многопоточность)

## В чем разница между `interrupted()` и `isInterrupted()`?
Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание потока вызовом `Thread.interrupt()` устанавливает этот флаг. Методы `Thread.interrupted()` и `isInterrupted()` позволяют проверить, является ли поток прерванным. 

Когда прерванный поток проверяет статус прерывания, вызывая статический метод `Thread.interrupted()`, статус прерывания сбрасывается. 

Нестатический метод `isInterrupted()` используется одним потоком для проверки статуса прерывания у другого потока, не изменяя флаг прерывания.

[к оглавлению](#Многопоточность)

## Что такое _«пул потоков»_?
Создание потока является затратной по времени и ресурсам операцией. Количество потоков, которое может быть запущено в рамках одного процесса также ограниченно. Чтобы избежать этих проблем и в целом управлять множеством потоков более эффективно в Java был реализован механизм пула потоков (thread pool), который создаётся во время запуска приложения и в дальнейшем потоки для обработки запросов берутся и переиспользуются уже из него. Таким образом, появляется возможность не терять потоки, сбалансировать приложение по количеству потоков и частоте их создания.

Начиная с Java 1.5 Java API предоставляет фреймворк `Executor`, который позволяет создавать различные типы пула потоков:

+ `Executor` - упрощенный интерфейс пула, содержит один метод для передачи задачи на выполнение;
+ `ExecutorService` - расширенный интерфейс пула, с возможностью завершения всех потоков;
+ `AbstractExecutorService` - базовый класс пула, реализующий интерфейс `ExecutorService`;
+ `Executors` - фабрика объектов связанных с пулом потоков, в том числе позволяет создать основные типы пулов;
+ `ThreadPoolExecutor` - пул потоков с гибкой настройкой, может служить базовым классом для нестандартных пулов;
+ `ForkJoinPool` - пул для выполнения задач типа `ForkJoinTask`;
+ ... и другие.

Методы `Executors` для создания пулов:

+ `newCachedThreadPool()` - если есть свободный поток, то задача выполняется в нем, иначе добавляется новый поток в пул. Потоки не используемые больше минуты завершаются и удалются и кэша. Размер пула неограничен. Предназначен для выполнения множество небольших асинхронных задач;
+ `newCachedThreadPool(ThreadFactory threadFactory)` - аналогично предыдущему, но с собственной фабрикой потоков;
+ `newFixedThreadPool(int nThreads)` - создает пул на указанное число потоков. Если новые задачи добавлены, когда все потоки активны, то они будут сохранены в очереди для выполнения позже. Если один из потоков завершился из-за ошибки, на его место будет запущен другой поток. Потоки живут до тех пор, пока пул не будет закрыт явно методом `shutdown()`.
+ `newFixedThreadPool(int nThreads, ThreadFactory threadFactory)` - аналогично предыдущему, но с собственной фабрикой потоков;
+ `newSingleThreadScheduledExecutor()` - однопотоковый пул с возможностью выполнять задачу через указанное время или выполнять периодически. Если поток был завершен из-за каких-либо ошибок, то для выполнения следующей задачи будет создан новый поток.
+ `newSingleThreadScheduledExecutor(ThreadFactory threadFactory)` - аналогично предыдущему, но с собственной фабрикой потоков;
+ `newScheduledThreadPool(int corePoolSize)` - пул для выполнения задач через указанное время или переодически;
+ `newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)` - аналогично предыдущему, но с собственной фабрикой потоков;
+ `unconfigurableExecutorService(ExecutorService executor)` - обертка на пул, запрещающая изменять его конфигурацию;

[к оглавлению](#Многопоточность)

## Какого размера должен быть пул потоков?
Настраивая размер пула потоков, важно избежать двух ошибок: слишком мало потоков (очередь на выполнение будет расти, потребляя много памяти) или слишком много потоков (замедление работы всей систему из-за частых переключений контекста). 

Оптимальный размер пула потоков зависит от количества доступных процессоров и природы задач в рабочей очереди. На N-процессорной системе для рабочей очереди, которая будет выполнять исключительно задачи с ограничением по скорости вычислений, можно достигнуть максимального использования CPU с пулом потоков, в котором содержится N или N+1 поток.
Для задач, которые могут ждать осуществления I/O (ввода - вывода) - например, задачи, считывающей HTTP-запрос из сокета – может понадобиться увеличение размера пула свыше количества доступных процессоров, потому, что не все потоки будут работать все время. Используя профилирование, можно оценить отношение времени ожидания (`WT`) ко времени обработки (`ST`) для типичного запроса. Если назвать это соотношение `WT/ST`, то для N-процессорной системе понадобится примерно `N*(1 + WT/ST)` потоков для полной загруженности процессоров.

Использование процессора – не единственный фактор, важный при настройке размера пула потоков. По мере возрастания пула потоков, можно столкнуться с ограничениями планировщика, доступной памяти, или других системных ресурсов, таких, как количество сокетов, дескрипторы открытого файла, или каналы связи базы данных.

[к оглавлению](#Многопоточность)

## Что будет, если очередь пула потоков уже заполнена, но подаётся новая задача?
Если очередь пула потоков заполнилась, то поданная задача будет «отклонена». Например - метод `submit()` у `ThreadPoolExecutor` выкидывает `RejectedExecutionException`, после которого вызывается `RejectedExecutionHandler`.

[к оглавлению](#Многопоточность)

## В чём заключается различие между методами `submit()` и `execute()` у пула потоков?
Оба метода являются способами подачи задачи в пул потоков, но между ними есть небольшая разница. 

`execute(Runnable command)` определён в интерфейсе `Executor` и выполняет поданную задачу и ничего не возвращает.

`submit()` – перегруженный метод, определённый в интерфейсе `ExecutorService`. Способен принимать задачи типов `Runnable` и `Callable` и возвращать объект `Future`, который можно использовать для контроля и управления процессом выполнения, получения его результата.

[к оглавлению](#Многопоточность)

## В чем заключаются различия между cтеком (stack) и кучей (heap) с точки зрения многопоточности?
__Cтек__ – участок памяти, тесно связанный с потоками. У каждого потока есть свой стек, которые хранит локальные переменные, параметры методов и стек вызовов. Переменная, хранящаяся в стеке одного потока, не видна для другого.

__Куча__ – общий участок памяти, который делится между всеми потоками. Объекты, неважно локальные или любого другого уровня, создаются в куче. Для улучшения производительности, поток обычно кэширует значения из кучи в свой стек, в этом случае для того, чтобы указать потоку, что переменную следует читать из кучи используется ключевое слово `volatile`.

[к оглавлению](#Многопоточность)

## Как поделиться данными между двумя потоками?
Данными между потоками возможно делиться, используя общий объект или параллельные структуры данных, например `BlockingQueue`.

[к оглавлению](#Многопоточность)

## Какой параметр запуска JVM используется для контроля размера стека потока?
`-Xss`

[к оглавлению](#Многопоточность)

## Как получить дамп потока?
Среды исполнения Java на основе HotSpot генерируют только дамп в формате HPROF. В распоряжении разработчика имеется несколько интерактивных методов генерации дампов и один метод генерации дампов на основе событий.

Интерактивные методы:

+ Использование <kbd>Ctrl+Break</kbd>: если для исполняющегося приложения установлена опция командной строки `-XX:+HeapDumpOnCtrlBreak`, то дамп формата HPROF генерируется вместе с дампом потока при наступлении события `Ctrl+Break` или `SIGQUIT` (обычно генерируется с помощью _kill -3_), которое инициируется посредством консоли. Эта опция может быть недоступна в некоторых версиях. В этом случае можно попытаться использовать следующую опцию:
`-Xrunhprof:format=b,file=heapdump.hprof`
+ Использование инструмента _jmap_: утилита _jmap_, поставляемая в составе каталога `/bin/` комплекта JDK, позволяет запрашивать дамп HPROF из исполняющегося процесса.
+ Использование операционной системы: Для создания файла ядра можно воспользоваться неразрушающей командой _gcore_ или разрушающими командами _kill -6_ или _kill -11_. Затем извлечь дамп кучи из файла ядра с помощью утилиты _jmap_.
+ Использование инструмента _JConsole_. Операция `dumpHeap` предоставляется в _JConsole_ как MBean-компонент `HotSpotDiagnostic`. Эта операция запрашивает генерацию дампа в формате HPROF.

Метод на основе событий:

+ Событие `OutOfMemoryError`: Если для исполняющегося приложения установлена опция командной строки `-XX:+HeapDumpOnOutOfMemoryError`, то при возникновении ошибки `OutOfMemoryError` генерируется дамп формата HPROF. Это идеальный метод для «production» систем, поскольку он практически обязателен для диагностирования проблем памяти и не сопровождается постоянными накладными расходами с точки зрения производительности. В старых выпусках сред исполнения Java на базе HotSpot для этого события не устанавливается предельное количество дампов кучи в пересчете на одну JVM; в более новых выпусках допускается не более одного дампа кучи для этого события на каждый запуск JVM.

[к оглавлению](#Многопоточность)

## Что такое _ThreadLocal-переменная_?
`ThreadLocal` - класс, позволяющий имея одну переменную, иметь различное её значение для каждого из потоков.

У каждого потока - т.е. экземпляра класса `Thread` - есть ассоциированная с ним таблица _ThreadLocal-переменных_. Ключами таблицы являются cсылки на объекты класса `ThreadLocal`, а значениями - ссылки на объекты, «захваченные» ThreadLocal-переменными, т.е. ThreadLocal-переменные отличаются от обычных переменных тем, что у каждого потока свой собственный, индивидуально инициализируемый экземпляр переменной. Доступ к значению можно получить через методы `get()` или `set()`.

Например, если мы объявим ThreadLocal-переменную: `ThreadLocal<Object> locals = new ThreadLocal<Object>();`. А затем, в потоке, сделаем `locals.set(myObject)`, то ключом таблицы будет ссылка на объект `locals`, а значением - ссылка на объект `myObject`. При этом для другого потока существует возможность «положить» внутрь `locals` другое значение.

Следует обратить внимание, что `ThreadLocal` изолирует именно ссылки на объекты, а не сами объекты. Если изолированные внутри потоков ссылки ведут на один и тот же объект, то возможны коллизии.

Так же важно отметить, что т.к. ThreadLocal-переменные изолированы в потоках, то инициализация такой переменной должна происходить в том же потоке, в котором она будет использоваться. Ошибкой является инициализация такой переменной (вызов метода `set()`) в главном потоке приложения, потому как в данном случае значение, переданное в методе `set()`, будет «захвачено» для главного потока, и при вызове метода `get()` в целевом потоке будет возвращен `null`.

[к оглавлению](#Многопоточность)

## Назовите различия между `synchronized` и `ReentrantLock`?
В Java 5 появился интерфейс `Lock` предоставляющий возможности более эффективного и тонкого контроля блокировки ресурсов. `ReentrantLock` – распространённая реализация `Lock`, которая предоставляет `Lock` с таким же базовым поведением и семантикой, как у `synchronized`, но расширенными возможностями, такими как опрос о блокировании (lock polling), ожидание блокирования заданной длительности и прерываемое ожидание блокировки. Кроме того, он предлагает гораздо более высокую эффективность функционирования в условиях жесткой _состязательности_.

Что понимается под блокировкой с повторным входом (reentrant)? Просто то, что есть подсчет сбора данных, связанный с блокировкой, и если поток, который удерживает блокировку, снова ее получает, данные отражают увеличение, и тогда для реального разблокирования нужно два раза снять блокировку. Это аналогично семантике synchronized; если поток входит в синхронный блок, защищенный монитором, который уже принадлежит потоку, потоку будет разрешено дальнейшее функционирование, и блокировка не будет снята, когда поток выйдет из второго (или последующего) блока synchronized, она будет снята только когда он выйдет из первого блока synchronized, в который он вошел под защитой монитора.

```java
Lock lock = new ReentrantLock();

lock.lock();
try { 
  // update object state
}
finally {
  lock.unlock(); 
}
```

+ Реализация `ReentrantLock` гораздо более масштабируема в условиях состязательности, чем реализация `synchronized`. Это значит, что когда много потоков соперничают за право получения блокировки, общая пропускная способность обычно лучше у `ReentrantLock`, чем у `synchronized`. JVM требуется меньше времени на установление очередности потоков и больше времени на непосредственно выполнение.
+ У `ReentrantLock` (как и у других реализаций `Lock`) блокировка должна обязательно сниматься в `finally` блоке (иначе, если бы защищенный код выбросил исключение, блокировка не была бы снята). Используя синхронизацию, JVM гарантирует, что блокировка автоматически снимаются.

Резюмируя, можно сказать, что когда состязания за блокировку нет либо оно очень мало, то `synchronized` возможно будет быстрее. Если присутствует заметное состязание за доступ к ресурсу, то скорее всего `ReentrantLock` даст некое преимущество.

[к оглавлению](#Многопоточность)

## Что такое `ReadWriteLock`?
`ReadWriteLock` – это интерфейс расширяющий базовый интерфейс `Lock`. Используется для улучшения производительности в многопоточном процессе и оперирует парой связанных блокировок (одна - для операций чтения, другая - для записи). Блокировка чтения может удерживаться одновременно несколькими читающими потоками, до тех пор, пока не появится записывающий. Блокировка записи является эксклюзивеной. 

Существует реализующий интерфейс `ReadWriteLock` класс `ReentrantReadWriteLock`, который поддерживает до 65535 блокировок записи и до стольки же блокировок чтения.

```java
ReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock rLock = rwLock.readLock();
Lock wLock = rwLock.writeLock();

wLock.lock();
try {
    // exclusive write
} finally {
    wLock.unlock();
}
        
rLock.lock();
try {
    // shared reading
} finally {
    rLock.unlock();
}        
```

[к оглавлению](#Многопоточность)

## Что такое _«блокирующий метод»_?
__Блокирующий метод__ – метод, который блокируется, до тех пор, пока задание не выполнится, например метод `accept()` у `ServerSocket` блокируется в ожидании подключения клиента. Здесь блокирование означает, что контроль не вернётся к вызывающему методу до тех пор, пока не выполнится задание. Так же существуют асинхронные или неблокирующиеся методы, которые могут завершится до выполнения задачи.

[к оглавлению](#Многопоточность)

## Что такое _«фреймворк Fork/Join»_?
Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров. Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно.

+ Этап Fork: большая задача разделяется на несколько меньших подзадач, которые в свою очередь также разбиваются на меньшие. И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.
+ Этап Join: далее (опционально) идёт процесс «свёртки» - решения подзадач некоторым образом объединяются пока не получится решение всей задачи. 

Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно. 

> Для решения некоторых задач этап Join не требуется. Например, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента. Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач.

Ещё одно замечательное преимущество этого фреймворка заключается в том, что он использует work-stealing алгоритм: потоки, которые завершили выполнение собственных подзадач, могут «украсть» подзадачи у других потоков, которые всё ещё заняты.

[к оглавлению](#Многопоточность)

## Что такое `Semaphore`?
Semaphore – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор. Доступ управляется с помощью счётчика: изначальное значение счётчика задаётся в конструкторе при создании синхронизатора, когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.

[к оглавлению](#Многопоточность)

## Что такое _double checked locking Singleton_?
__double checked locking Singleton__ - это один из способов создания потокобезопасного класса реализующего шаблон Одиночка. Данный метод пытается оптимизировать производительность, блокируясь только случае, когда экземпляр одиночки создаётся впервые.

```java
class DoubleCheckedLockingSingleton {
    private static volatile DoubleCheckedLockingSingleton instance;

    static DoubleCheckedLockingSingleton getInstance() {
        DoubleCheckedLockingSingleton current = instance;
        if (current == null) {
            synchronized (DoubleCheckedLockingSingleton.class) {
                current = instance;

                if (current == null) {
                    instance = current = new DoubleCheckedLockingSingleton();
                }
            }
        }
        return current;
    }
}
```

Следует заметить, что требование `volatile` обязательно. Проблема Double Checked Lock заключается в модели памяти Java, точнее в порядке создания объектов, когда возможна ситуация, при которой другой поток может получить и начать использовать (на основании условия, что указатель не нулевой) не полностью сконструированный объект. Хотя эта проблема была частично решена в JDK 1.5, однако рекомендация использовать `volatile` для Double Cheсked Lock остаётся в силе.

[к оглавлению](#Многопоточность)

## Как создать потокобезопасный Singleton?
+ __Static field__

```java
public class Singleton {
	public static final Singleton INSTANCE = new Singleton();
}
```

+ __Enum__

```java
public enum Singleton {
	INSTANCE;
}
```

+ __Synchronized Accessor__

```java
public class Singleton {
	private static Singleton instance;
	
	public static synchronized Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
}
```

+ __Double Checked Locking & `volatile`__

```java
public class Singleton {
        private static volatile Singleton instance;
	
        public static Singleton getInstance() {
		Singleton localInstance = instance;
		if (localInstance == null) {
			synchronized (Singleton.class) {
				localInstance = instance;
				if (localInstance == null) {
					instance = localInstance = new Singleton();
				}
			}
		}
		return localInstance;
	}
}
```

+ __On Demand Holder Idiom__

```java
public class Singleton {
		
	public static class SingletonHolder {
		public static final Singleton HOLDER_INSTANCE = new Singleton();
	}
		
	public static Singleton getInstance() {
		return SingletonHolder.HOLDER_INSTANCE;
	}
}
```

[к оглавлению](#Многопоточность)

## Чем полезны неизменяемые объекты?
Неизменяемость (immutability) помогает облегчить написание многопоточного кода. Неизменяемый объект может быть использован без какой-либо синхронизации. К сожалению, в Java нет аннотации `@Immutable`, которая делает объект неизменяемым, для этого разработчикам нужно самим создавать класс с необходимыми характеристиками. Для этого необходимо следовать некоторым общим принципам: инициализация всех полей только в конструкторе, отсутствие методов `setX()` вносящих изменения в поля класса, отсутствие утечек ссылки, организация отдельного хранилища копий изменяемых объектов и т.д.

[к оглавлению](#Многопоточность)

## Что такое _busy spin_?
__busy spin__ – это техника, которую программисты используют, чтобы заставить поток ожидать при определённом условии. В отличие от традиционных методов `wait()`, `sleep()` или `yield()`, которые подразумевают уступку процессорного времени, этот метод вместо уступки выполняет пустой цикл. Это необходимо, для того, чтобы сохранить кэш процессора, т.к. в многоядерных системах, существует вероятность, что приостановленный поток продолжит своё выполнение уже на другом ядре, а это повлечет за собой перестройку состояния процессорного кэша, которая является достаточно затратной процедурой.

[к оглавлению](#Многопоточность)

## Перечислите принципы, которым вы следуете в многопоточном программировании?
При написании многопоточных программ следует придерживаться определённых правил, которые помогают обеспечить достойную производительность приложения в сочетании с удобной отладкой и простотой дальнейшей поддержки кода.

+ Всегда давайте значимые имена своим потокам. Процесс отладки, нахождения ошибок или отслеживание исключения в многопоточном коде – довольно сложная задача. `OrderProcessor`, `QuoteProcessor` или `TradeProcessor` намного информативнее, чем `Thread1`, `Thread2` и `Thread3`. Имя должно отражать задачу, выполняемую данным потоком.
+ Избегайте блокировок или старайтесь уменьшить масштабы синхронизации. Блокировка затратна, а переключение контекста ещё более ресурсоёмко. Пытайтесь избегать синхронизации и блокировки насколько это возможно, и организуйте критическую секцию в минимально необходимом объёме. Поэтому синхронизированный блок всегда предпочительней синхронизированного метода, дополнительно наделяя возможностью абсолютного контроля над масштабом блокировки.
+ Обрабатывайте прерывание потока с особой тщательностью. Нет ничего хуже оставшегося заблокированным ресурса или системы в неконстистентном, по причине неподтверждённой транзакции, состоянии.
+ Помните об обработке исключений. Выброшенные `InterruptedException` должны быть адекватно обработаны, а не просто подавлены. Так же не стоит пренебрегать `Thread.UncaughtExceptionHandler`. При использовании пула потоков необходимо помнить, что он зачастую просто «проглатывает» исключения. Так, если вы отправили на выполнение `Runnable` нужно обязательно поместить код выполнения задачи внутрь блока `try-catch`. Если в очередь пула помещается `Callable`, необходимо удостоверится, что результат выполнения всегда изымается помощью блокирующего `get()`, чтобы в случае возникновения существовала возможнотсь заново выбросить произошедшее исключение.
+ Между синхронизаторами и `wait()` и `notify()` следует выбирать синхронизаторы. Во-первых, синхронизаторы, типа `CountDownLatch`, `Semaphore`, `CyclicBarrier` или `Exchanger` упрощают написание кода. Очень сложно реализовывать комплексный управляющий поток, используя `wait()` и `notify()`. Во-вторых, эти классы написаны и поддерживаются настоящими мастерами своего дела и есть шанс, что в последующих версиях JDK они будут оптимизированы изнутри или заменены более производительной внешней реализацией.
+ Почти всегда использование Concurrent сollection выгоднее использования Synchronized сollection, т.к. первые более современны (используют все доступные на момент их написания новшества языка) и масштабируемы, чем их синхронизированые аналоги.

[к оглавлению](#Многопоточность)

## Какое из следующих утверждений о потоках неверно?
1. Если метод `start()` вызывается дважды для одного и того же объекта `Thread`, во время выполнения генерируется исключение.
2. Порядок, в котором запускались потоки, может не совпадать с порядком их фактического выполнения.
3. Если метод `run()` вызывается напрямую для объекта `Thread`, во время выполнения генерируется исключение.
4. Если метод `sleep()` вызывается для потока, во время выполнения синхронизированного кода, блокировка не снимается.

Правильный ответ: 3. Если метод `run()` вызывается напрямую для объекта `Thread`, во время выполнения исключение не генерируется. Однако, код, написанный в методе `run()` будет выполняться текущим, а не новым потоком. Таким образом, правильный способ запустить поток – это вызов метода `start()`, который приводит к выполнению метода `run()` новым потоком. 

Вызов метода `start()` дважды для одного и того же объекта `Thread` приведёт к генерированию исключения `IllegalThreadStateException` во время выполнения, следовательно, утверждение 1 верно. Утверждение 2 верно, так как порядок, в котором выполняются потоки, определяется Планировщиком потоков, независимо от того, какой поток запущен первым. Утверждение 4 верно, так как поток не освободит блокировки, которые он держит, когда он переходит в состояние Ожидания.

[к оглавлению](#Многопоточность)

## Даны 3 потока Т1, Т2 и Т3? Как реализовать выполнение в последовательности Т1, Т2, Т3?
Такой последовательности выполнения можно достичь многими способами, например просто воспользоваться методом `join()`, чтобы запустить поток в момент, когда другой уже закончит своё выполнение. Для реализации заданной последовательности, нужно запустить последний поток первым, и затем вызывать метод `join()` в обратном порядке, то есть Т3 вызывает `Т2.join`, а Т2 вызывает `Т1.join`, таким образом Т1 закончит выполнение первым, а Т3 последним.

[к оглавлению](#Многопоточность)

## Напишите минимальный неблокирующий стек (всего два метода — `push()` и `pop()`).
```java
class NonBlockingStack<T> {
    private final AtomicReference<Element> head = new AtomicReference<>(null);

    NonBlockingStack<T> push(final T value) {
        final Element current = new Element();
        current.value = value;
        Element recent;
        do {
            recent = head.get();
            current.previous = recent;
        } while (!head.compareAndSet(recent, current));
        return this;
    }

    T pop() {
        Element result;
        Element previous;
        do {
            result = head.get();
            if (result == null) {
                return null;
            }
            previous = result.previous;
        } while (!head.compareAndSet(result, previous));
        return result.value;
    }

    private class Element {
        private T value;
        private Element previous;
    }
}
```

[к оглавлению](#Многопоточность)

## Напишите минимальный неблокирующий стек (всего два метода — `push()` и `pop()`) с использованием `Semaphore`.
```java
class SemaphoreStack<T> {
    private final Semaphore semaphore = new Semaphore(1);
    private Node<T> head = null;

    SemaphoreStack<T> push(T value) {
        semaphore.acquireUninterruptibly();
        try {
            head = new Node<>(value, head);
        } finally {
            semaphore.release();
        }

        return this;
    }

    T pop() {
        semaphore.acquireUninterruptibly();
        try {
            Node<T> current = head;
            if (current != null) {
                head = head.next;
                return current.value;
            }
            return null;
        } finally {
            semaphore.release();
        }
    }

    private static class Node<E> {
        private final E value;
        private final Node<E> next;

        private Node(E value, Node<E> next) {
            this.value = value;
            this.next = next;
        }
    }
}
```

[к оглавлению](#Многопоточность)

## Напишите минимальный неблокирующий ArrayList (всего четыре метода — `add()`, `get()`, `remove()`, `size()`).
```java
class NonBlockingArrayList<T> {
    private volatile Object[] content = new Object[0];

    NonBlockingArrayList<T> add(T item) {
        return add(content.length, item);
    }

    NonBlockingArrayList<T> add(int index, T item) {
        if (index < 0) {
            throw new IllegalArgumentException();
        }
        boolean needsModification = index > content.length - 1;
        if (!needsModification) {
            if (item == null) {
                needsModification = content[index] != null;
            } else {
                needsModification = item.equals(content[index]);
            }
        }
        if (needsModification) {
            final Object[] renewed = Arrays.copyOf(content, Math.max(content.length, index + 1));
            renewed[index] = item;
            content = renewed;
        }
        return this;
    }

    NonBlockingArrayList<T> remove(int index) {
        if (index < 0 || index >= content.length) {
            throw new IllegalArgumentException();
        }
        int size = content.length - 1;
        final Object[] renewed = new Object[size];
        System.arraycopy(content, 0, renewed, 0, index);
        if (index + 1 < size) {
            System.arraycopy(content, index + 1, renewed, index, size - index);
        }
        content = renewed;
        return this;
    }

    T get(int index) {
        return (T) content[index];
    }

    int size() {
        return content.length;
    }
}
```

[к оглавлению](#Многопоточность)

## Напишите потокобезопасную реализацию класса с неблокирующим методом `BigInteger next()`, который возвращает элементы последовательности: `[1, 2, 4, 8, 16, ...]`.
```java
class PowerOfTwo {
    private AtomicReference<BigInteger> current = new AtomicReference<>(null);
    
    BigInteger next() {
        BigInteger recent, next;
        do {
            recent = current.get();
            next = (recent == null) ? BigInteger.valueOf(1) : recent.shiftLeft(1);
        } while (!current.compareAndSet(recent, next));
        return next;
    }
}
```
[к оглавлению](#Многопоточность)

## Напишите простейший многопоточный ограниченный буфер с использованием `synchronized`.
```java
class QueueSynchronized<T> {
    private volatile int size = 0;
    private final Object[] content;
    private final int capacity;

    private int out;
    private int in;

    private final Object isEmpty = new Object();
    private final Object isFull = new Object();

    QueueSynchronized(final int capacity) {
        this.capacity = capacity;
        content = new Object[this.capacity];
        out = 0;
        in = 0;
        size = 0;
    }

    private int cycleInc(int index) {
        return (++index == capacity)
                ? 0
                : index;
    }

    @SuppressWarnings("unchecked")
    T get() throws InterruptedException {
        if (size == 0) {
            synchronized (isEmpty) {
                while (size < 1) {
                    isEmpty.wait();
                }
            }
        }
        try {
            synchronized (this) {
                final Object value = content[out];
                content[out] = null;
                if (size > 1) {
                    out = cycleInc(out);
                } 
                size--;
                return (T) value;
            }
        } finally {
            synchronized (isFull) {
                isFull.notify();
            }
        }
    }

    QueueSynchronized<T> put(T value) throws InterruptedException {
        if (size == capacity) {
            synchronized (isFull) {
                while (size == capacity) {
                    isFull.wait();
                }
            }
        }
        synchronized (this) {
            if (size == 0) {
                content[in] = value;
            } else {
                in = cycleInc(in);
                content[in] = value;
            }
            size++;
        }
        synchronized (isEmpty) {
            isEmpty.notify();
        }
        return this;
    }
}
```
[к оглавлению](#Многопоточность)

## Напишите простейший многопоточный ограниченный буфер с использованием `ReentrantLock`.
```java
class QueueReentrantLock<T> {

    private volatile int size = 0;
    private final Object[] content;
    private final int capacity;

    private int out;
    private int in;

    private final ReentrantLock lock = new ReentrantLock();
    private final Condition isEmpty = lock.newCondition();
    private final Condition isFull = lock.newCondition();

    QueueReentrantLock(int capacity) {
        try {
            lock.lock();
            this.capacity = capacity;
            content = new Object[capacity];
            out = 0;
            in = 0;
        } finally {
            lock.unlock();
        }
    }

    private int cycleInc(int index) {
        return (++index == capacity)
                ? 0
                : index;
    }

    @SuppressWarnings("unchecked")
    T get() throws InterruptedException {
        try {
            lock.lockInterruptibly();
            if (size == 0) {
                while (size < 1) {
                    isEmpty.await();
                }
            }
            final Object value = content[out];
            content[out] = null;
            if (size > 1) {
                out = cycleInc(out);
            }
            size--;
            isFull.signal();
            return (T) value;
        } finally {
            lock.unlock();
        }
    }

    QueueReentrantLock<T> put(T value) throws InterruptedException {
        try {
            lock.lockInterruptibly();
            if (size == capacity) {
                while (size == capacity) {
                    isFull.await();
                }
            }
            if (size == 0) {
                content[in] = value;
            } else {
                in = cycleInc(in);
                content[in] = value;
            }
            size++;
            isEmpty.signal();
        } finally {
            lock.unlock();
        }
        return this;
    }
}
```

[к оглавлению](#Многопоточность)

# Источники
+ [Хабрахабр - Многопоточность в Java](https://habrahabr.ru/post/164487/)
+ [IBM DeveloperWorks - Выполнение задач в многопоточном режиме](https://www.ibm.com/developerworks/ru/library/l-java_universe_multithreading_tasks/)
+ [Записки трезвого практика](http://www.skipy.ru/technics/synchronization.html)
+ [IBM DeveloperWorks - SCJP](https://www.ibm.com/developerworks/ru/edu/j-scjp/section8.html)
+ [JavaRush](http://info.javarush.ru/KapChook/2015/02/15/Перевод-Топ-50-интервью-вопросов-по-нитям-Часть-1-.html)
+ [Хабрахабр - Справочник по синхронизаторам `java.util.concurrent.*`](https://habrahabr.ru/post/277669/)
+ [Блог сурового челябинского программиста](http://samolisov.blogspot.ru/2011/04/threadlocal.html)
+ [IBM DeveloperWorks - Более гибкая, масштабируемая блокировка в JDK 5.0](http://www.ibm.com/developerworks/ru/library/j-jtp10264/)
+ [Хабрахабр - Правильный Singleton в Java](https://habrahabr.ru/post/129494/)
+ [duct-tape-architect.ru](http://www.duct-tape-architect.ru/?p=294#3__171_187___Java_HotSpot_JVM6)

[Вопросы для собеседования](README.md)
